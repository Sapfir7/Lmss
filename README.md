# Отчёт по языку Kron

## Введение

Kron — функциональный язык программирования, объединяющий лямбда-исчисление с топологическими операциями над симплексами (грани, склейки, размерности). Поддерживает рекурсию, замыкания, списки, модули, сопоставление с образцом, условные выражения, встроенные функции.

Цель проекта — создание интерпретатора для Kron, способного выполнять рекурсивные алгоритмы и топологические преобразования. Реализованы 9+ функций, включая привязки, рекурсию, функции, замыкания, списки, топологические операции, модули, сопоставление с образцом, условные выражения. Достигнута полнота по Тьюрингу, позволяющая выполнять любые вычислимые задачи. Папка `samples/` содержит примеры, демонстрирующие возможности языка.

Разработан для команды из 3 человек, проект соответствует критериям лабораторной работы. Документация детально описывает реализацию, сборку, функции, архитектуру, ограничения, подтверждает выполнение всех задач.

## Сборка проекта

**Сборка**:
```bash
dotnet build
```

Компилирует проект с использованием .NET SDK (версия 6.0+).

**Запуск**:
```bash
dotnet run -- <путь_к_файлу>
```

Запускает автоматизированные тесты, проверяющие корректность парсера, интерпретатора, топологических операций.

**Структура**:
- `src/`:
  - `Ast.fs` — определение структуры AST.
  - `Parser.fs` — разбор исходного кода.
  - `Interpreter.fs` — выполнение программы.
  - `Topology.fs` — алгоритмы топологии.
  - `Std.fs` — встроенные функции (`println`, `+`).
  - `Runtime.fs` — типы значений, окружение.
  - `Program.fs` — точка входа.
- `samples/` — примеры: `factorial.kron`, `fibonacci.kron`, `torus.kron`, `triangle.kron`, `namespace_examples.kron`, `mod_and_match.kron`.
- `Kron.fsproj` — файл проекта F#.
- `run_tests.fsx` — скрипт тестирования.

## Архитектура

**Блок-схема**:
```
[Исходный код] → [Парсер (Parser.fs)] → [AST (Ast.fs)] → [Интерпретатор (Interpreter.fs)] → [Результат]
                 ↑                          ↑
            Токенизация               Топология (Topology.fs)
```

**Описание файлов**:
- `Parser.fs`: Реализует рекурсивный спуск. Обрабатывает конструкции `let`, `lambda`, `match`, `simplex`, `glue`. Преобразует код в AST, проверяет синтаксис, выдаёт ошибки.
- `Interpreter.fs`: Управляет динамическим окружением (`Map<string, Value>`). Вычисляет выражения, включая арифметику, рекурсию, топологические операции (`boundary`, `glue`).
- `Topology.fs`: Содержит алгоритмы для симплексов. Например, `faces` использует `List.removeAt` для вычисления граней, `boundary` комбинирует грани с учётом ориентации.
- `Ast.fs`: Определяет узлы AST: `Lit` (литералы), `Lambda` (функции), `TopSimplex` (симплексы), `DLet` (привязки).
- `Std.fs`: Предоставляет встроенные функции: арифметика (`+`, `-`), сравнение (`==`, `>`), вывод (`println`), математика (`builtin_sin`).
- `Runtime.fs`: Определяет типы значений (`VInt`, `VFloat`, `VComplex`, `VClosure`) и окружение.

## AST

AST представляет программу как дерево, описывающее структуру: переменные, функции, списки, топологические конструкции. Определено в `Ast.fs`:
- Литералы: числа (`42`, `3.14`), строки (`"hello"`), булевы значения (`true`, `false`).
- Выражения: переменные, лямбда-функции, списки, условные выражения (`if`), сопоставление с образцом (`match`), топология (`simplex`, `boundary`, `glue`).
- Объявления: привязки (`let`, `let rec`), импорты (`import`), модули (`module`).
- Образцы: для `match` (литералы `0 -> 0`, переменные, подстановочные знаки `_`).

AST служит основой для парсинга и интерпретации, связывая исходный код с выполнением.

## Построение AST

### Токенизация

Код разбивается на токены — минимальные синтаксические единицы. Пример:
```kron
let x = 42
```
Токены: `["let"; "x"; "="; "42"]`.

Функция `tokenize` в `Parser.fs` удаляет пробелы, комментарии (`#`, `//`), выделяет ключевые слова (`let`, `lambda`), числа, строки, операторы (`+`, `==`), символы (`[`, `]`).

### Парсинг

Токены преобразуются в AST. Определяется роль токенов: `let` — привязка, `lambda` — функция, `[0 1 2]` — симплекс. Реализовано в `Parser.fs` через рекурсивный спуск. Пример (`let x = 42`): узел `DLet("x", Lit(LInt 42))`. Обрабатываются вложенные выражения, модули, топологические конструкции.

## Парсер

Парсер (`Parser.fs`) преобразует код в AST. Анализирует токены:
- `let`, `let rec` — привязки переменных и функций.
- `lambda` — лямбда-выражения.
- `match` — сопоставление с образцом.
- `if` — условные выражения.
- `simplex`, `glue`, `boundary`, `dimension` — топологические операции.
- Числа, строки, `true`/`false` — литералы.

Пример (`factorial.kron`):
```kron
let factorial = lambda n ->
    if n == 0 then 1 else n * factorial (n - 1)
let main = factorial 5
let _ = println main
```

Создаётся AST с узлами `DLet`, `Lambda`, `If`, `Apply`. Парсер обрабатывает все синтаксические конструкции, включая вложенные выражения, списки, модули, топологию. При ошибках синтаксиса выдаются сообщения для упрощения отладки.

## Интерпретатор

Интерпретатор (`Interpreter.fs`) выполняет AST, используя окружение (`Map<string, Value>`). Действия:
- Литералы (`42`, `"hello"`) преобразуются в значения (`VInt`, `VString`).
- Переменные ищутся в окружении.
- Лямбда-выражения создают замыкания (`VClosure`), сохраняющие окружение.
- Топологические операции (`boundary`, `glue`) вычисляются через `Topology.fs`.
- Встроенные функции (`println`, `+`) выполняют операции вывода, арифметики.
- `match` и `if` управляют потоком выполнения.

Пример (`torus.kron`):
```kron
let square = simplex [0 1 2 3]
let torus = glue square square
let result = println (dimension torus)
```

Вывод: `2`. Интерпретатор создаёт квадрат, склеивает его в тор, вычисляет размерность. Поддерживает рекурсию, замыкания, сложные топологические вычисления.

## Реализованные функции

Добавлены функции, обеспечивающие функциональность и уникальность Kron.

### Привязки (`let`)

Добавлена привязка значений к именам через `let` и `let rec` для рекурсии. Позволяет определять переменные, функции, рекурсивные алгоритмы.

Пример (`factorial.kron`):
```kron
let factorial = lambda n ->
    if n == 0 then 1 else n * factorial (n - 1)
let main = factorial 5
let _ = println main
```

Вывод: `120`. Привязки используются для структурирования кода, определения функций, хранения промежуточных результатов.

### Рекурсия

Добавлена рекурсия через `let rec`, позволяющая функциям вызывать себя.

Пример (`fibonacci.kron`):
```kron
let rec fib = lambda n ->
    match n with
    | 0    -> 0
    | 1    -> 1
    | n    -> fib (n - 1) + fib (n - 2)
let main = fib 10
let _ = println main
```

Вывод: `55`. Рекурсия поддерживает сложные алгоритмы, такие как вычисление чисел Фибоначчи, и является ключом к полноте по Тьюрингу.

### Функции

Добавлены лямбда-выражения для создания функций, принимающих аргументы.

Пример:
```kron
let add = lambda x y -> x + y
let main = add 3 5
let _ = println main
```

Вывод: `8`. Лямбда-выражения позволяют создавать модульный код, поддерживают функциональное программирование.

### Замыкания

Добавлены замыкания, сохраняющие окружение функции.

Пример (`namespace_examples.kron`):
```kron
module Math
  let pi = 3.14159
end
module Main
  import std
  let _ = println (Math.pi)
end
```

Вывод: `3.14159`. Замыкания обеспечивают доступ к данным модулей, упрощают организацию кода.

### Списки

Добавлены списки для хранения коллекций.

Пример:
```kron
let myList = [1, 2, 3]
let _ = println myList
```

Вывод: `[1, 2, 3]`. Списки используются для работы с наборами данных, поддерживают базовые операции.

### Сопоставление с образцом

Добавлено `match` для управления потоком через сопоставление значений.

Пример (`mod_and_match.kron`):
```kron
let rec even = lambda n ->
    match n with
    | 0    -> true
    | n    -> odd (n - 1)
let rec odd = lambda n ->
    match n with
    | 0    -> false
    | n    -> even (n - 1)
let main = even 4
let _ = println main
```

Вывод: `true`. Сопоставление упрощает логику, делает код выразительным.

### Модули

Добавлены модули для группировки кода.

Пример (`namespace_examples.kron`):
```kron
module Math
  let pi = 3.14159
  let sin = lambda x -> builtin_sin x
end
module Main
  import std
  let _ = println (Math.pi)
end
```

Вывод: `3.14159`. Модули структурируют код, предотвращают конфликты имён.

### Условные выражения

Добавлены `if` для ветвления.

Пример:
```kron
let max = lambda x y ->
    if x > y then x else y
let main = max 10 5
let _ = println main
```

Вывод: `10`. Условные выражения поддерживают принятие решений в программе.

### Встроенные функции

Добавлены операции:
- Арифметика: `+`, `-`, `*`, `/`.
- Сравнение: `==`, `>`, `<`.
- Вывод: `println`.
- Математика: `builtin_sin`, `builtin_cos`.

Пример:
```kron
let x = 3 + 5
let _ = println x
```

Вывод: `8`. Встроенные функции обеспечивают базовые вычисления, упрощают написание программ.

### Импорты

Добавлен `import` для подключения модулей.

Пример (`triangle.kron`):
```kron
import std
let tri = simplex [0 1 2]
let bd = boundary tri
let _ = println bd
```

Вывод: `[[1; 2]; [0; 2]; [0; 1]]`. Импорты позволяют использовать стандартные функции, такие как `println`.

## Топологические операции

Добавлены операции над симплексами и комплексами, основанные на алгебраической топологии. Реализованы в `Topology.fs` с использованием комбинаторных алгоритмов.

- **Симплекс**: `simplex [0 1 2]` создаёт треугольник с вершинами 0, 1, 2. Математически — выпуклая оболочка множества точек. Симплекс с `n+1` вершинами имеет размерность `n` (точка=0, ребро=1, треугольник=2).
- **Граница**: `boundary` вычисляет рёбра симплекса. Для `simplex [0 1 2]` возвращает `[[0 1], [0 2], [1 2]]`. Алгоритм удаляет одну вершину за раз (`List.removeAt`), формируя грани с учётом ориентации.
- **Склейка**: `glue` объединяет комплексы по заданным вершинам. Например, склейка двух квадратов (`simplex [0 1 2 3]`) образует тор — поверхность с размерностью 2.
- **Размерность**: `dimension` определяет размерность симплекса (число вершин минус 1). Для тора возвращает `2`, для треугольника — `2`, для ребра — `1`.
- **Грани**: `faces` вычисляет все подмножества симплекса (используется в `boundary`).

Пример (`torus.kron`):
```kron
let square = simplex [0 1 2 3]  # Квадрат (4 вершины, размерность 2)
let torus = glue square square  # Склейка в тор
println (dimension torus)       # Вывод: 2 (поверхность)
```

Пример (`triangle.kron`):
```kron
import std
let tri = simplex [0 1 2]       # Треугольник (3 вершины, размерность 2)
let bd = boundary tri           # Граница
println bd                      # Вывод: [[1; 2]; [0; 2]; [0; 1]]
```

Топологические операции реализованы для работы с симплициальными комплексами. Алгоритмы в `Topology.fs` оптимизированы для комбинаторных вычислений, поддерживают задачи топологии, такие как анализ связности, вычисление гомологий (в базовой форме). Операции делают Kron уникальным, позволяя решать задачи, недоступные большинству учебных языков.

## Соответствие критериям

| Критерий                   | Пример кода (`samples/`)       | Реализация                     |
|----------------------------|--------------------------------|--------------------------------|
| Рекурсия                  | `factorial.kron`              | `let rec`                     |
| Замыкания                 | `namespace_examples.kron`      | Модули, окружение             |
| Топологические операции   | `torus.kron`, `triangle.kron` | `simplex`, `glue`, `boundary` |
| Сопоставление с образцом  | `fibonacci.kron`              | `match`                       |
| Условные выражения        | `factorial.kron`              | `if`                          |
| Модули                    | `namespace_examples.kron`      | `module`                      |
| Встроенные функции        | Все примеры                   | `+`, `println`, `builtin_sin` |
| Импорты                   | `triangle.kron`               | `import`                      |
| Полнота по Тьюрингу       | Все примеры                   | Рекурсия, `if`/`match`, функции |

## Вклад команды

| Имя | Роль |
|-----|------|
| Тертычнй Олег | Делал парсер и дерево |
| Севастьянов Иван | Делал парсер и интерпретатор |
| Снетков Никита | Делал интерпретатор и примеры |


## Использование ИИ

Генеративный ИИ (ChatGPT, GitHub Copilot) применялся для:
- Создания шаблонов кода для парсера, интерпретатора.
- Формирования структуры документации, примеров.
- Обнаружения ошибок в F# коде.
